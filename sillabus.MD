### Sillabus

## 1. Giriş

1. Proqramlaşdırmaya giriş
2. Dart proqramlaşdırma dilinə giriş
3. DartPad ilə tanışlıq

## 2. Dart Əsasları

1. Giriş
2. `main` method nədir?
3. Hello world- ilk proqramın yazılması
4. Dəyişənlər və tanımlanması
5. Dəyişən tipləri
6. **Praktiki iş**: dəyişənlərin çapı
7. String tipi üzərində əməllər
8. **Praktiki iş**: String interposiya
9. String qaçış əməliyyatları
10. Mətn tipli string ifadələrin yazılması
11. Sadə String əməliyyatlar: uppercase və lowercase
12. Initialization və Assignment fərqi
13. **Praktiki iş**: Lowercase və uppercase stringlər
14. Stringlər üzərində axtarma və dəyişmə əməliyyatları
15. Dəyişən tipləri arasındakı mümkün çevirmələr.
16. Riyazi operatorlar
17. **Praktiki iş**: Temperaturun çevrilməsi
18. Artırma & Azalatma operatorları
19. Məntiqi operatorlar
20. Ternary- şərt operatorları
21. Hex format, bitwise & shifting operatorları
22. Komentlər
23. Expressions & statement fərqi və izahları

## 3. Dart dəyişən tipi sistemi

1. Giriş
2. Statik və Dinamik Proqramlaşdırma Dilləri
3. `var` dəyişən tipi
4. `final` açar sözü
5. `const` açar sözü
6. **Praktiki iş**: `var`, `final` and `const`
7. `dynamic` açar sözü

## 4. İdarə edicilər

1. Giriş
2. If/else ifadələri
3. **Praktiki iş**: if/else
4. while döngüsü
5. for döngüsü
6. **Praktiki iş**: fizz buzz təyini
7. `break` and `continue`
8. switch ifadəsi
9. enumerationlar
10. **Praktiki iş**: Sadə kalkulyator

## 5. Layihə: “command line app” qurulması

1. Giriş
2. Dart SDK nın qurulması
3. VS Code-un qurulması
4. **Layihə Mahiyyəti**: Daş, Kağız & Qayçı
5. “command line app”-ın qurulması
6. Oyun məntiqi üçün Pseudocode
7. İsitifadəçidən məlumat alma
8. Oyun döngüsünün əlavəsi
9. Oyun məntiqinin tamamlanması

## 6. Kolleksiyalar

1. Giriş
2. Listlər
3. **Praktiki iş**: Listdəki rəqəmlərin cəmlənməsi
4. List metodları
5. List annotasiyaları
6. `var`, `final`, `const` açar sözlərin listlə işlənməsi
7. Set-lər
8. **Praktiki iş**: Set
9. Map-lar
10. `as` operatoru
11. `null` dəyər
12. Map-lar dəyərləri üzərində gəzmə
13. **Exercise**: Pizza Ordering
14. İç-içə Kolleksiyalar
15. **Praktiki iş**: Restarant reytinqləri
16. **Exercise**: Alış veriş listi
17. Kolleksiyaların kopyalanması

## 7. Layihə: Dart-da məlumatlar üzərində işləmə

1. Giriş
2. Konsoldan alınmış məlumatların düzgün istifadəsi
3. Faylları oxumaq
4. Prosesin məntiqi üçün Pseudocode
5. Prosesin məntiqi icarısının təmini

## 8. “Dart Null Safety”

1. Null Safety- ə giriş
2. Nullable və non-nullable dəyişənlər
3. Assertion operatoru
4. İf-null operatoru

## 9. Funksiyalar: Əsasları

1. Giriş
2. Funksiya arqumentləri
3. Return dəyərləri
4. **Praktiki iş**: Listdəki rəqəmlərin cəmi
5. Adlandırılmış və Sabit yerli arqumentlər
6. Required və varsayılan qiymətlər
7. Varsayılan sabit yerli arqumentlər
8. **Praktiki iş**: Pizza sifariş funsiyaları
9. “Fat arrow” ilə qısaltmalar
10. Qlobal və lokal əhatə dairəsi
11. Daxili Funksiyalar

## 10. Funksiyalar: Qabaqcıl

1. Giriş
2. Anonim funksiyalar
3. Function tipləri
4. `forEach` metodu
5. `map` metodu
6. `Iterable` və `toList()`
7. Kodları yenidən istifadəsi

## 11. Siniflər: Əsasları

1. Giriş
2. Instance methodları
3. Sinif qurucular və `this` açar sözü
4. Siniflər dəyişməz üzvlərlə
5. **Praktiki iş**: `Person` sinifini qurulması
6. “Type safety”
7. `const` qurucuları
8. Adlandırılmış qurucular
9. Alıcılar and Ayarlayıcılar
10. **Praktiki iş**: Restarant reytinq misalı siniflərlə
11. Statik methodlar və dəyişənlər
12. Gizli dəyişənlər və methodlar

## 12. Siniflər: Qabaqcıl

1. Giriş
2. VS Code Dart Null Safety qurulması
3. “inheritance / subclassing” - giriş
4. `super` qurucusu
5. Metodları overriding etmə
6. Mücərrəd siniflər
7. **Praktiki iş**: Sahə və Perimetr hesablama
8. Interfaces və `implements` and `extends` arasındakı fərq
9. `Object` sinfi
10. `toString()` metodu
11. “Equatable” paketi
12. JSON nədir
13. Factory qurucular və JSON məlumatın oxunması
14. **Praktiki iş**: JSON Serialization
15. `copyWith` metodunun mahiyyəti
16. Cascade operatoru

## 13. Layihə: Sadə e -ticarət

1. Giriş
2. Məhsul, Səbət, və.s siniflərinin yaradılması
3. Səbətə əlavə etmə funksionallağının əlavəsi

## 14. Mixins & Extensions

1. Giriş
2. Mixinlərin yaradılması və istifadəsi
3. Mixinlər
4. Extensionlar

## 15. Xəta və İstisanayi halların nəzarət alınması

1. Giriş
2. İstisnalar: `throw`, `try`, `catch`, `finally` və.s
3. **Praktiki iş**: Email yoxlama

## 16. Asinxron Proqramlama

1. Giriş
2. `then`, `catchError`, `whenComplete` öhdəlikləri
3. `async` və `await`
4. `Future.value` və `Future.error`
5. **Praktiki iş**: GeriSayım proqramı
6. Stream-lər
7. `async*` and `yield`
8. **Praktiki iş**: Fizz-buzz streamlərlə
9. Stream qurucular
10. Stream metodları
11. Tək / Çox abunəli stream-lar

## 17. Hava haqqında proqramı

1. Giriş
2. REST API əsasları
3. http paketi giriş
4. qayıdış status kodunun və məlumatın oxunması
5. JSON məlumatın siniflərə görə ayrılması
6. Xətaların nəzərə alınması

///////

## 18. Flutter və digər lazımlı proqram təminatlarının yüklənməsi

1. Android studio-nun qurulması
2. Android Emulatorun qurulması
3. Paketlər üçün versiyaların önəmi

## 19. Flutter-a giriş

1. Android studion ilk proqramın yaradılması
2. Qovluqlaşdırmanın üstünlükləri
3. Android emulator-un açıllması və test edilməsi
4. İlk mövcud proqram üzərində tanışlıq
5. Hot reload və hot restart ilə tanışlıq
6. Widgetlərə giriş
7. MaterialApp widget
8. Scaffold widget
9. Flutter widget sıralaması
10. Stateless and stateful widgetlər
11. Sayğacın setState ilə artırılması

## 20. Görünüş (Uİ)

1. MaterialApp
2. Qovluqların əlavəsi
3. Giriş ekranının əlavəsi
7. Kodun oxunaqlılığının təmini
8. Metodlara bölünmək, atomarlığın təmin edilməsi


## 1-ci Həftənin widgetləri 
1. Text
2. SizedBox
3. Container
4. Padding
5. İcon
6. İmage
7. Scaffold
8. Column
9. Row
10. ElevatedButton
11. AppBar

### 2-ci Həftənin widgetləri 
1. Align
2. AcpectRatio
3. Center
4. CustomSingleChildLayout
5. Expanded
6. FittedBox
7. LimitedBox
8. SizedBox
9. Transform

### 3-cü Həftənin widgetləri 
1. Form
2. FormField
3. RichText
4. Text
5. TextButton
6. Checkbox
7. Date & Time Pickers
8. TextField

### 4-cü Həftənin widgetləri 
1. MediaQuery
2. BottomNavigationBar
3. Drawer
4. TabBar
5. DropdownButton
6. FloatingActionButton
7. IconButton
8. PopupMenuButton
9. Slider

### 5-ci Həftənin widgetləri 
1. Switch
2. Radio
3. AlertDialog
4. BottomSheet
5. ExpansionPanel
6. SimpleDialog
7. SnackBar

### 6-cı Həftənin widgetləri 
1. Card
2. Chip
3. CircularProgressIndicator
4. DataTable
5. GridView
6. LinearProgressIndicator
7. Tooltip

### 7-ci Həftənin widgetləri 
1. Divider
2. ListTile
3. Stepper
4. FutureBuilder
5. StreamBuilder
6. ClipRect
7. RotatedBox

### 8-ci Həftənin widgetləri 
1. AnimatedAlign
2. AnimatedBuilder
3. AnimatedContainer
4. AnimatedCrossFade
5. AnimatedOpacity
6. AnimatedSize
7. AnimatedPositioned
8. FadeTransition
9. Hero





### 21. Platforma özəl widget və dialoglar

1. Dialoglara giriş
2. Dialoqun yaradılması və göstərilməsi
3. Dialoqun bağlanması
4. Platforma özəl widget və dialoglar iOS və Android
5. Yenidən istifadə edilə bilən showAlertDialog metodunun yaradılması
6. Çıxış et dialoqunun yaradılması
7. Android və iOS dialoq fərqlilikləri

### 7. Firebase Authentication

1. Local and remote authentication
2. Introduction to Firebase
3. Creating a Firebase project
4. Configuring Firebase for Android
5. Configuring Firebase for iOS
6. Installing the firebase_core and firebase_auth packages
7. Initializing the Firebase App
8. Running on iOS and updating Cocoapods
9. Futures, async and await
10. Signing in anonymously with Firebase
11. The FirebaseAuth singleton and private constructors
12. Explaining the short-hand syntax for callbacks
13. Error handling with try/catch

### 8. Full Authentication Flow, State Management & Dependency Injection

1. Preview of the sign-in and sign-out flow
2. Creating a landing page widget
3. Adding a Firebase User to the LandingPage
4. Adding a callback to the SignInPage
5. Hooking up the onSignIn callback
6. Creating the home page
7. Adding the sign-out functionality
8. Hooking up the onSignOut callback
9. Retrieving the current user when the app starts
10. Explaining global access and scoped access
11. Creating the Auth class
12. The abstract AuthBase class
13. Using the Auth class
14. Lifting state up and its drawbacks
15. State Management & App Architecture

### 9. Streams and StreamBuilder

1. Introduction to Streams
2. Streams in practice with DartPad
3. Handling errors and closing streams
4. The authStateChanges stream
5. Listening to the authStateChanges stream
6. Adding the StreamBuilder code
7. More on StreamBuilder
8. Refactoring the sign-in flows
9. Wrap-up on Streams and StreamBuilder

### 10. Google and Facebook sign-in

1. Overview of the Firebase sign-in methods
2. Enabling support for Google Sign In
3. Adding Google Sign-In to the Auth class
4. Hooking up Google Sign-In to our button
5. Configuring Google Sign-In on iOS
6. Google Sign-In flow explained
7. Supporting Google Sign Out
8. Testing Google Sign-In on Android
9. Viewing registered users on the Firebase console
10. Registering a Facebook App
11. Enabling Facebook Sign-In on Firebase
12. Installing the Facebook login package
13. Enabling MultiDex support on Android
14. Adding the Facebook Sign-In code
15. Testing Facebook Sign-In on Android
16. Facebook iOS setup in Xcode
17. Testing Facebook Sign-In on iOS
18. Accessing the user's data and privacy considerations

### 11. Email & Password Sign-In + Handling Text Input

1. Preview of the email & password sign-in page
2. Creating the email & password sign-in page
3. Passing the BuildContext across methods
4. Introduction to navigation
5. Adding a Card widget
6. Adding the email and password text fields
7. Adding the submit buttons
8. Creating a FormSubmitButton widget
9. Adding a TextEditingController
10. Toggling the form type
11. Adding the email & password authentication code
12. Implementing the submit method
13. Testing email & password sign-in
14. Customising the email and password text fields
15. Using FocusNode and FocusScope
16. Disabling the submit button on empty email or password
17. Adding a StringValidator class
18. Adding an email and password validation mixin
19. Showing an error text when the email or password are invalid
20. Tweaking form submission
21. Simulating a slow network with a delay
22. Adding a loading state to our form
23. Updating the email focus logic
24. Fixing the vertical overflow on small screens
25. Wrap-up

### 13. Scoped Access with InheritedWidget and Provider

1. Introduction to InheritedWidget
2. Creating an AuthProvider
3. Accessing the Auth object via the AuthProvider
4. Adding the provider package
5. Using the Provider class
6. Wrap-up about scoped access and Provider

### 14. Polishing the Authentication flows

1. Module Introduction
2. Creating better user-facing errors with FirebaseAuthException
3. Creating a custom exception alert dialog
4. Showing error alerts in the SignInPage
5. Adding a loading state: overview
6. Adding a loading state to the SignInPage
7. Using the loading state in the SignInPage
8. The dispose method

### 15. BLoCs

1. Introduction to state management with BLoCs
2. The application layers
3. BLoCs, sinks, streams, and asynchronous code
4. Introduction to the SignInBloc
5. Implementing a simple BLoC
6. Adding a Bloc with Provider inside a static method
7. Adding the StreamBuilder code
8. Converting the SignInPage to a stateless widget
9. The difference between Provider.of and Consumer
10. Disposing BLoCs with Provider
11. Adding authentication code to the SignInBloc
12. Updating the SignInPage
13. Fixing the BLoC submit method
14. Summary on the BLoC basics
15. Introduction to the email sign-in flow with BLoC
16. Creating a model class for the EmailSignInForm
17. Creating the EmailSignInBloc with a StreamController
18. Updating the model
19. Adding the BLoC submit method
20. Setting up the EmailSignInFormBlocBased with Provider
21. Refactoring the EmailSignInFormBlocBased widget by removing the state variables
22. Moving the business logic to the BLoC class
23. Moving more business logic to the model class
24. The benefits of separation of concerns with BLoC
25. Using stateful widgets with TextEditingControllers
26. Considerations about performance
27. Blocs and Services in the widget tree

### 16. State Management with Provider

1. Recap on State Management
2. Introduction to ValueNotifier
3. Adding a ValueNotifier with ChangeNotifierProvider
4. Consumer and ChangeNotifierProvider explained
5. Differences between BLoC/streams and ValueNotifier/ChangeNotifierProvider
6. Introduction to ChangeNotifier
7. Adding the EmailSignInChangeModel class
8. Completing the EmailSignInChangeModel class
9. Implementing the email sign-in form with ChangeNotifier
10. Comparing ValueNotifier and ChangeNotifier
11. Wrap up on State Management
12. Wrap up on the Authentication Flows

### 17. Databases and Cloud Firestore

1. Overview of the time tracker app
2. Database schema and SQL vs NoSQL
3. Introduction to Cloud Firestore
4. Documents and Collections
5. Getting started with Firestore
6. Designing a Database API with CRUD operations
7. Managing private user data with Cloud Firestore
8. Installing Cloud Firestore
9. Renaming the HomePage to JobsPage
10. Adding the Database class
11. Adding the Database Provider
12. Adding a FloatingActionButton
13. Writing data to Firestore
14. Defining a strongly-typed Job model class
15. Defining a common API path class
16. Adding a generic setData method
17. Adding security rules
18. Handling Firestore permissions errors
19. Reading data from Firestore
20. Reading and parsing Firestore data streams
21. Adding a StreamBuilder to show a list of jobs
22. Debugging the StreamBuilder code
23. Firestore as a realtime database
24. Adding a factory constructor to our model class
25. Adding a generic method to read Firestore streams
26. Adding a FirestoreService class
27. Wrap-up on Cloud Firestore

### 18. Working with Forms and Cloud Firestore

1. Introduction to Forms with Cloud Firestore
2. Adding a new job page
3. The Placeholder widget
4. Introduction to Form and TextFormField
5. Validating and saving Form data
6. Accessing the Database object with the correct BuildContext
7. Saving jobs with a unique document ID
8. Handling errors
9. Enforcing unique job names
10. Fixing the integer-parsing code
11. Editing existing jobs: overview
12. Adding a custom JobListTile
13. Repurposing the AddJobPage for editing jobs
14. Reading the documentID from Firestore
15. Completing the code for editing jobs
16. Wrap up on working with Forms

### 19. Working with ListViews and multiple UI states

1. Intro and multiple states of UI
2. Adding an empty content widget
3. Adding a reusable list items builder
4. Using ListView.builder
5. Using ListView.separated
6. Deleting jobs from Firestore
7. Adding swipe to delete support

### 20. Working with Date & Time Pickers, more on Cloud Firestore

1. Working with entries: overview
2. Relational data & drawbacks of NoSQL databases
3. Getting ready to add new files
4. Adding the source files to the project
5. Connecting the new code and updating the Firestore rules
6. Fixing the EditJobPage navigation
7. Overview of the JobEntriesPage
8. Reading and writing entries with Firestore
9. The EntryListItem widget (using InkWell and Expanded)
10. Formatting dates and currencies with the Intl package
11. Dart as UI: Spreads and Collection-if
12. Using date pickers with stateful widgets
13. Date and time input with a custom UI and DateTimePicker
14. Updating the UI when a Job changes
15. Wrap up and CupertinoDatePicker

### 21. Bottom Navigation with the Cupertino widgets

1. Introduction to bottom navigation
2. Multiple navigation stacks
3. Creating a HomePage with a selected tab
4. Adding a CupertinoTabScaffold
5. Testing the bottom navigation
6. Adding the widget builders
7. Replacing the FloatingActionButtons
8. Moving the logout button to the AccountPage
9. Presenting modal routes with the root navigator
10. The CupertinoPageRoute
11. Handling the Android back button with WillPopScope and navigator keys
12. Adding pop-to-root navigation
13. Wrap up on multiple navigators

### 22. Advanced Stream Operations with RxDart

1. Introduction to advanced stream operations
2. Introduction to RxDart
3. Observable.combineLatest and data transformations in the time tracker app
4. Adding the source code for the new entries page
5. Reviewing the UI code for the entries page
6. Using combineLatest in practice
7. Data manipulation in the EntriesBloc
8. Wrap up on Observables
9. Single subscription vs broadcast streams
10. PublishSubject, ReplaySubject, BehaviorSubject
11. Adding a BehaviorSubject to the EmailSignInBloc
12. Wrap up and notes about local and remote state management

### 23. Completing the Time Tracker App

1. Completing the time tracker app: overview
2. Accessing the User object in the AccountPage
3. Adding an Avatar image
4. Finishing the Avatar code
5. Wrapping up the time tracker app

### 24. Unit & Widget Tests with Mockito

1. Introduction to writing tests
2. Testing Flutter Apps
3. Writing the first unit test
4. Running tests
5. Checking and fixing errors in tests
6. Testing edge cases by writing and fixing failing tests
7. Grouping tests together
8. The setUp method and testing date formatting with locales
9. The test lifecycle methods
10. Completing the formatting tests
11. Testing model classes
12. hashCode and the == operator
13. Adding a toString() method, wrap up on unit tests
14. Introduction to widget tests
15. Finding widgets and matcher arguments
16. Testing widget callbacks
17. Working with Acceptance Criteria
18. Introduction to test mocks and mockito
19. Injecting mock objects with Provider
20. Verifying mock methods
21. Working with keys, entering text and the pump() method
22. Testing widget updates on state changes
23. Completing the email sign-in tests
24. Replacing Navigator.pop with a callback when the user signs in
25. Updating the tests to handle the form callback
26. Stubbing mock objects
27. Recap on the email sign in forms and stubbing mocks
28. Using widget tests with StreamBuilder
29. Using StreamController inside tests
30. Adding a Database builder to the Landing Page
31. Test setup for the SignInPage
32. Adding keys to custom widget classes
33. Testing navigation
34. The great thing about widget tests
35. Testing ValueNotifier models
36. Testing ChangeNotifier models
37. Testing BloCs
38. Comparing EmailSignInModel objects
39. Testing streams in Blocs
40. Wrap up on unit & widget tests
